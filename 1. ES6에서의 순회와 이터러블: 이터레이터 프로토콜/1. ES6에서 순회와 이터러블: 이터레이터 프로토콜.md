# 사용자 정의 이터러블, 이터러블/이터레이터 프로토콜 정의

```js
const iterable = {
  [Symbol.iterator](){
    let i = 3;
      return {
        next(){
          return i == 0 ? {done: true} : {value: i--, done: false};
      }
    }
  }
}

let iterator = iterable[Symbol.iterator]();

iterator.next(); // {value: 3, done: false}

iterator.next(); // {value: 2, done: false}

for (const a of iterable) console.log(a); // 3 2 1

```

하지만, 아직 이러한 문제가 있다.  

```js
for (const a of iterator) console.log(a); // Uncaught TypeError: iterator is not iterable
```

잘 만들어진 이터레이터는 자기 자신을 반환하는 `[Symbol.iterator]()` 를 가지고 있어야 한다.  
우리가 만든 iterator 는 `이터레이터 객체인건 맞지만, 이터러블하지 않아서` 이터러블 객체를 기대하는 for 문 안에서 사용할 수 없다.  
즉, iterator 는 반환값으로 `[Symbol.itertor]()` 를 반환하지 않는다.  

<br/>

🥸 이터러블하게 수정해보기


```js
const iterable = {
  [Symbol.iterator](){
    let i = 3;
      return {
        next(){
          return i == 0 ? {done: true} : {value: i--, done: false};
      },
      [Symbol.iterator]() {return this; }
    }
  }
}

let iterator = iterable[Symbol.iterator]();
for (const a of iterator) console.log(a); // 3 2 1
```

# 전개 연산자
```js
const a = [1,2];
console.log(...a, [3,4]); // [1, 2, 3, 4]

a[Symbol.iterator] = null;
console.log(...a, [3,4]); // Uncaught TypeError: object is not iterable (cannot read property Symbol(Symbol.iterator))
```


전개 연산자는 이터러블 프로토콜을 따른느 객체를 받아 그 내용을 개별 요소로 펼쳐준다.  
이때 내부적으로 이터러블 프로토콜의 `[Symbol.iterator]()` 를 호출해서 이터레이터를 가져오고, 이 이터레이터의 `next()` 메소드를 사용하여 모든 요소를 순회한다.  

```js
const arr = [1, 2, 3];
const str = "hello";

console.log([...arr]); // [1, 2, 3]
console.log([...str]); // ['h', 'e', 'l', 'l', 'o']
```
