# 기존과 달라진 ES6에서의 리스트 순회

ES6 이전
```js
const list = [1,2,3];
for (var i = 0; i < list.length; i++){
  log(list[i]);
}

const str = 'abc';
for (var i = 0; i < str.length; i++){
  log(str[i]);
};
```

ES6
```js
for (const a of list) {
  log(a);
}

for (const a of str){
  log(a);
}
```

-> 보다 선언적이고 간결하게 변경되었다.


# 이터러블 / 이터레이터 프로토콜
## 이터러블: 이터레이터를 리턴하는 `[Symbol.iterator]()` 를 가진 값
```js
const arr = [1,2,3];
arr[Symbol.iterator] // ƒ values() { [native code] }
arr[Symbol.iterator]() // Array Iterator {}

arr[Symbol.iterator] = null; // Uncaught TypeError: arr is not iterable 
```

arr은 이터레이터를 리턴하는 `[Symbol.iterator]()` 을 가졌기 때문에 이터러블하다.  
이터러블은 `[Symbol.iterator]()` 로 실행했을때 이터레이터를 리턴한다.  


![image](https://github.com/hjk329/Functional-Programming/assets/84058944/96384b60-460f-4804-bf29-e2aaee8ed7bb)

<br/>

## 이터레이터: {value, done} 객체를 리턴하는 `next()` 를 가진 값
```js
let iterator = arr[Symbol.iterator]()
iterator.next() // {value: 1, done: false}
```

![image](https://github.com/hjk329/Functional-Programming/assets/84058944/fc107f43-5e96-4e22-b32d-2a4f272ac3d1)   

이터레이터는 `next()` 메소드를 통해 {value, done} 객체를 리턴하도록 하는 값이다.  

## 이터러블 / 이터레이터 프로토콜: 이터러블을 for...of, 전개 연산자 등과 함께 동작하도록 한 규약


# 이터레이터 이해해보기

```js
const arr = [1,2,3];

let iter1 = arr[Symbol.iterator](); // 이터레이터 객체
iter1.next();

for (const a of iter1) log(a); // 2 3
```




